{"categories":[],"posts":[{"content":"一句话总结就是：每个会话在指定目录下创建一个键值对，谁先创建成功谁就是主。\n背景 我们在使用 etcd 时，会利用 etcd 来实现进程抢主的逻辑。 etcd go 的SDK提供了封装好的 concurrency 模块来简化分布式选主的实现。如下，是一个忽略了错误处理的选主实现示例。\n 那么，etcd clientv3 的 Election 具体是怎么实现的呢？如何保证在任意情况下只有一个实例成为 leader ？\n内部实现 etcd 维护了一个全局递增的版本号，对应于每次原子修改。这个版本号称之为 Version。相应的，对于每个保存在 etcd 中的 Key 也保存了这个 Key 是在哪一个 Version 时创建的信息，称之为 CreateRevision。\n当用户调用Election.Campaign方法时，etcd client 就会尝试创建一个 Key(如何已经存在，就不创建，直接取值)，并纪录下这个 Key 的 CreateRevision 。接着，etcd client会遍历指定目录下所有的版本小于 CreateRevision 的 Key。如果不存在小于 CreateRevision 的 Key，则说明当前创建的 Key 就是最早的 Key 了，该会话可以安全的成为 leader。否则，etcd client 会一直监听目录下这些小于 CreateRevision 的 Key，直到所有的 Key 都被删除。\n","id":0,"section":"posts","summary":"\u003cp\u003e一句话总结就是：每个会话在指定目录下创建一个键值对，谁先创建成功谁就是主。\u003c/p\u003e","tags":null,"title":"Etcd SDK 中的选主实现","uri":"https://liuchang0812.github.io/2019/11/etcd-client-election/","year":"2019"},{"content":" 为什么要发明 RAFT 一致性协议？ 因为 paxos 过于复杂，难以理解。同时，paxos 是面向学术和理论证明，没有在论文中介绍工程上的实现。如果要实现一个工业级的 paxos，要做很多优化拓展，例如 multi-paxos。为了解决这些问题， raft 是一个把可理解性、明确工程实现方法放在首要考虑地位的算法。\nRAFT 算法细节 raft 算法主要分为两个部分: 1)Leader Election; 2)Log Replication。\n基本概念  term, 每次 leader 变更时就增长1。每个 term 内只会有一个 leader。时间的逻辑划分，用于 leader election。 RPC，不同结点之间通过 RPC 来通信，在 raft 中有两个 RPC: 1)RequestVote;2)AppendEntries。  Leader Election 空的 AppendEntries RPC 被用来作为心跳包，由 Leader 发送给其它 Server，同时维持其的Leader角色（Leader Authority）。当一个 Server 在超过一定时间(election timeout)没有收来自Leader的心跳包，就认为 Leader 不存在，开始新一轮的选举。\n选举的策略比较简单，每个 Server 在每个 Term 只给一个人投票，遵循先到先得的策略。为了尽量避免出现 split 投不出大多数的情况，每个 Server 都有一个随机的election timeout配置，来避免多个 Server 在同时发出 RequestVote 请求。\nLog Replication committed log: 保证持久化的日志，不会因为机器故障等各类原因丢失该日志。并且该日志最终会被所有可用机器执行。\n日志满足一个特性 Log Matching Property，类似于归纳法。对于不同的日志，只有他们的term和index相同,他们的内容一定相同。同时他们之前日志的内容也相同。\nConsistency Check: When send- ing an AppendEntries RPC, the leader includes the index and term of the entry in its log that immediately precedes the new entries. If the follower does not find an entry in its log with the same index and term, then it refuses the new entries.\nLeader 日志是immutable的，follower 的日志是可以覆盖的：\na leader creates at most one entry with a given log index in a given term, and log entries never change their position in the log. the leader handles inconsistencies by forcing the followers’ logs to duplicate its own. This means that conflicting entries in follower logs will be overwritten with entries from the leader’s log.\nLeader 通过给 Follower 不停的发送 AppendEntries RPC 来找到 follower 的日志起点（term和index都相同）。\nSafety Leader Completeness Property: the leader for any given term con- tains all of the entries committed in previous terms Leader Completeness Property: Leader Completeness Prop\n","id":1,"section":"posts","summary":"为什么要发明 RAFT 一致性协议？ 因为 paxos 过于复杂，难以理解。同时，paxos 是面向学术和理论证明，没有在论文中介绍工程上的实现。如果要实现一个工业级","tags":null,"title":"Raft Paper Notes","uri":"https://liuchang0812.github.io/2019/10/raft-paper-notes/","year":"2019"},{"content":" Build Seastar git clone https://github.com/scylladb/seastar.git cd seastar git submodule update --init --recursive apt udpate \u0026amp;\u0026amp; ./install-dependencies.sh ./configure.py --mode=release --cook fmt  Link with Seastar apt install libunistring-dev export seastar_dir=`pwd` g++ my_app.cc $(pkg-config --libs --cflags --static $seastar_dir/build/release/seastar.pc) -o my_app ./my_app  ","id":2,"section":"posts","summary":" Build Seastar git clone https://github.com/scylladb/seastar.git cd seastar git submodule update --init --recursive apt udpate \u0026amp;\u0026amp; ./install-dependencies.sh ./configure.py --mode=release --cook fmt  Link with Seastar apt install libunistring-dev export seastar_dir=`pwd` g++ my_app.cc $(pkg-config --libs --cflags --static $seastar_dir/build/release/seastar.pc) -o my_app ./my_app  ","tags":null,"title":"Build and Link with SeaStar library","uri":"https://liuchang0812.github.io/2019/09/install-seastar/","year":"2019"},{"content":"","id":3,"section":"posts","summary":"","tags":null,"title":"My First Post","uri":"https://liuchang0812.github.io/2019/01/my-first-post/","year":"2019"}],"tags":[]}